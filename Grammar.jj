/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Grammar.jj */
/*@egen*/PARSER_BEGIN(PatinaParser)

package parser;

import ast.Assignment;
import ast.Declaration;
import ast.Bool;
import ast.Flt;
import ast.IExpression;
import ast.Identifier;
import ast.Int;
import ast.Mult;
import ast.TypeCheckable;
import java.util.LinkedList;

public class PatinaParser/*@bgen(jjtree)*/implements PatinaParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTPatinaParserState jjtree = new JJTPatinaParserState();

/*@egen*/
}
PARSER_END(PatinaParser)

/* Special tokens are ignored by the parser, but can still be recovered during parsing if necessary. */
SPECIAL_TOKEN :
{
    < WHITESPACE : (["\n", "\r", "\t", " "])+ >
|   < SINGLE_LINE_COMMENT : "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

TOKEN : /* KEYWORDS */
{
    < BE : "be" >
|   < FALSE : "false" >
|   < FN : "fn" >
|   < IF: "if" >
|   < LET : "let" >
|   < MUT : "mut" >
|   < RETURN : "return" >
|   < SET: "set" >
|   < TRUE : "true" >
|   < WHILE : "while" >
}

TOKEN : /* SYMBOLS */
{
    < LARROW : "<-" >
|   < RARROW : "->" >

|   < LPAR : "(" >
|   < RPAR : ")" >
|   < LCBR : "{" >
|   < RCBR : "}" >
|   < LSBR : "[" >
|   < RSBR : "]" >
|   < LABR : "<" >
|   < RABR : ">" >

|   < COLON : ":" >
|   < COMMA : "," >
|   < PERIOD : "." >

|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULT : "*" >
|   < DIV : "/" >
|   < MOD : "%" >

|   < AMP : "&" >
|   < CARET : "^" >
|   < EXCLAMATION : "!" >
|   < PIPE : "|" >
|   < SHIFTL : "<<" >
|   < SHIFTR : ">>" >

|   < EQ : "=" >
|   < LEQ : "<=" >
|   < GEQ : ">=" >
|   < NEQ : "!=" >
}

TOKEN : /* IDENTIFIERS */
{
    < IDENTIFIER : <LETTER> (<LETTER>|<DIGIT>)* >
|   < #LETTER : ["_","a"-"z","A"-"Z"] >
|   < #DIGIT : ["0"-"9"] >
}

TOKEN : /* LITERALS */
{
        < INTEGER_LITERAL :  (<DIGIT>)+ >
   |    < FLOATING_LITERAL : <INTEGER_LITERAL> "." <INTEGER_LITERAL> >
}


/* Top-level production */
LinkedList<TypeCheckable> Input() :
{/*@bgen(jjtree) Input */
    SimpleNode jjtn000 = new SimpleNode(JJTINPUT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    TypeCheckable a, d;
    IExpression e;
    LinkedList<TypeCheckable> result = new LinkedList<TypeCheckable>();
}
{/*@bgen(jjtree) Input */
        try {
/*@egen*/
        (
        LOOKAHEAD(3)
            d = Declaration() <PERIOD> { result.add(d); }
        |
            LOOKAHEAD(3)   
            a = Assignment()  <PERIOD> { result.add(a); }
        |
            LOOKAHEAD(3)
            e = Expression()  <PERIOD> { result.add(e); }
        )+
        <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { return result; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TypeCheckable Declaration() :
{/*@bgen(jjtree) Declaration */
    SimpleNode jjtn000 = new SimpleNode(JJTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    TypeCheckable id, md;
}
{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/
    (
    LOOKAHEAD(3)
        id = ImmutableDeclaration()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/ { return id; }
    |   md = MutableDeclaration()/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/ { return md; }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

TypeCheckable ImmutableDeclaration() : // must be an assignment
{/*@bgen(jjtree) ImmutableDeclaration */
        SimpleNode jjtn000 = new SimpleNode(JJTIMMUTABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	IExpression e;
}
{/*@bgen(jjtree) ImmutableDeclaration */
    try {
/*@egen*/
    t = <LET> <IDENTIFIER> <BE> Type() <LARROW> e = Expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new Assignment(new Identifier(t.image), e); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

TypeCheckable MutableDeclaration() : // does not need to be assigned anything
{/*@bgen(jjtree) MutableDeclaration */
    SimpleNode jjtn000 = new SimpleNode(JJTMUTABLEDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) MutableDeclaration */
    try {
/*@egen*/
    t = <LET> <IDENTIFIER> <BE> Type() <MUT> (<LARROW> Expression())?/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new Declaration(t.image); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*void FunctionDeclaration() :
{}
{
    <LET> <IDENTIFIER>
}*/

IExpression Expression() :
{/*@bgen(jjtree) Expression */
    SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    IExpression result, b;
}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    result = UnaryExpression() // renamed atomic expression
    (
        (<PLUS> | <MINUS> | <MULT> | <DIV> | <MOD>)
        b = UnaryExpression()
        { result = new Mult(result, b); }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return result; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

IExpression UnaryExpression() :
{/*@bgen(jjtree) UnaryExpression */
    SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) UnaryExpression */
    try {
/*@egen*/
    t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ { return new Int(Integer.parseInt(t.image)); }
|   t = <FLOATING_LITERAL>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ { return new Flt(Float.parseFloat(t.image)); }
|   t = <IDENTIFIER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { return new Identifier(t.image); }
|   <TRUE>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { return new Bool(true); }
|   <FALSE>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ { return new Bool(false); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type() :
{/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Assignment Assignment() :
{/*@bgen(jjtree) Assignment */
    SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    IExpression rhs;
}
{/*@bgen(jjtree) Assignment */
    try {
/*@egen*/
    t = <IDENTIFIER> <LARROW> rhs = Expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ // assign equals
    { return new Assignment(new Identifier(t.image), rhs); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}